# Взаимодействующие последовательные процессы

Простой язык для описания конкурентных процессов, взаимодействующих посредством обмена сообщениями, разработанный в 1978 сэром Чарльзом Энтони Ричардом Хоаром.

_CSP_ (Communicating sequential processes) использует текст для описания систем:

- `keyboard?c` - считать значение с клавиатуры и назвать `c`
- `console!c` - отправить `c` процессу "консоль"
- `keyboard?c || mouse?pos` - считать с клавиатуры и мыши _параллельно_
- `x := y + 1` присвоить значение `y+1` иксу
- `[x>0 -> sign:=1 || x<0 -> sign:=-1]` - если икс больше нуля, присвоить `sign` единицу, иначе, если меньше, минус единицу

В CSP, как и в большинстве систем обмена сообщениями, нет понятия портов, все процессы получают сообщения напрямую. Можем считать это одиночным скрытым портом без имени. Дуги называются _каналами_, они синхронные в том смысле, что писатель не может слать, покуда читатель не вычитал, и передают 1 сообщение за раз.

Единственный, наиболее часто встречающийся артефакт CSP в разных его реализациях это "канал". Многие реализации CSP реализуют каналы, но заменяют "процессы" чем-то своим. Каналы являются чрезвычайно полезными примитивами для построения Dataflow системы - они реализованы во множестве ЯП и имеют очень простую семантику.

## Каналы

Каналы отделяют писателя от читателя. В CSP они не имеют буфера и синхронны. Писатель блокируется, пока читатель не читает. Множество реализаций заменило это на буферизированные FIFO каналы с фиксированной вместимостью.

Как только значение прочтено, оно удаляется из канала. Последующее чтение даст следующее значение. Один поток пишет в канал и другой из него читает. Канал эквивалентен дуге без разделений.

Размер буфера обычно заранее (на момент создания канала, не обязательно компиляции) задан и не может быть изменён. Это, однако, в теории, может быть и не так.

Множество писателей могут послать значение в один и тот же канал, имитируя слияние дуг. Для того, чтоб все читатели получили все сообщения нужно создать узел с одним входом и множеством выходов, который будет копировать сообщения.

Канал является типом данных и сам может быть сохранён в любой коллекции или передаваться из одного места в другое.

Будучи заполнен, буфер блокирует писателя, так что важно грамотно управлять ресурсами программы. Каналы без буфера настоятельно не рекомендуются.

## Каналы как примитив синхронизации

Каналы популярны т.к. могут применяться для строительства других конкурентных операторов.

_Future_ это write-once переменная которая не может содержать в моменте значения, но будет в будущем. _Promise_ это процесс, который может присваивать значение футуре. Future это просто канал с буфером 1, а promise это процесс, который пишут туда единожды.

_Семафор_ это устройство фиксированному кол-ву процессов делить общую память. Реализовать с помощью канала можно так: берётся канал с фиксированным буфером (равным кол-ву процессов), для запроса доступа процесс пишет в этот канал. Как только канал заполнен (макс. кол-во процессов шарит память), происходит блокировка в том месте, где канал заполнился. Разблокировка произойдёт только тогда, когда один из процессов отпустит ресурс. Другой способ это взять канал без буфера, напихать туда значений и заставлять процессы оттуда вычитываться, а по завершении писать.
