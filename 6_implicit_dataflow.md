# Неявное Dataflow

Dataflow может рассматриваться как способ программирования на любом языке и не требует явного _движка_.

Всякий раз, объединяя действия в цепочки, вы программируете в Dataflow стиле. И хоть чаще всего для передачи сообщений используются каналы, это совершенно не обязательно. **Генеральная идея это _отделение отправителя от получателя_.**

Давайте сравним это с традиционным _call/return_ стилем, когда отправитель знает, кому он отправляет данные и что он получает в ответ. _Отправитель и получатель тесно связаны_.

Что если, вместо отправки аргументов напряму в функцию, мы бы просто поместили данные в переменную, к которой у обоих, отправителя и получателя, есть доступ?

В реальности всё сложнее из-за _проблемы конкурентного доступа_, но в качестве упрощения такая модель сойдёт. Ключевая мысль тут в том, что **механизм коммуникации не так важен, как сам факт отделения отправителя от получателя**. Если обыкновенная разделяемая память (переменная) работает в вашем случае, то вперёд.

Некоторые возможные способы коммуникации:

- Unix pipes
- Сокеты
- Функции
- Разделяемый файл
- Разделяемая память
- Управляемая коммуникация

Некоторые из этих подходов неудобны, когда речь идёт о многопоточности. **Dataflow не трубет многопоточности**. _Если всё, что вам нужно, это возможность лёгкой композиции действий, забудьте о многопоточности_.

## Unix Pipes

Самая известная реализация dataflow. Маленькие программы, которые взаимодействуют с помощью строк, позволяют вам выполнять масштабные задачи, объединённые в shell скрипты.

## Сокеты

Сокеты могут объединять действия на одной или нескольких машинах. Природа сокетов почти требует нескольких процессов или потоков, но сами действия могут быть написаны, будто они однопоточны.

## Функции

Функции, которые принимают один аргумент и возвращает его же без изменений могут быть использованы для разделения двух действий. Функция исполняет роль _трубы_ (pipe) между двумя действиями. Обычно есть верхоуровневый модуль, который определяет соединения между _действиями_. Сами действия запрограммированы в таком же стиле - принимают 1 аргумент и возвращают его же.

В каком-то модуле мы бы определили все нужные пайплайны. Такой модуль был бы просто одним файлом, мы редактировали бы только его, всякий раз, когда надо поменять что-то в пайплайнах.

Это очень удобно в языках, где можно переопределять инфиксные операторы вроде `+, -, ->`. Иначе будет много скобочек и вместо 

```
action1 -> action2 -> action3
```

Будет 

```
action3(action2(action1()))
```

Т.е порядок операций обратен тому, как мы их применяем.

## Управляемая коммуникация

Разделяемые ресурсы, такие как память или файлы, чаще всего комбинируются с того или иного вида _менеджером активации_.

В однопоточной среде мы просто создаем разделяемое хранилище о котором все знают.  Во время активации процесс берёт оттуда входные данные и пишет туда выходные.

Менеджер активации может быть просто процедурой, кторая определяет порядок вызовов процессов.

```
manager(){
    action1();
    action2();
    action3();
}
```

## Каналы для обмена сообщениями

Крайне рекомендуется, если только нет веской причины для иного, использовать каналы для коммуникации между процессами. Иногда их просто нет в языке (глава о CSP, однако, рассказывает, как их реализовать), а иногда есть ещё какие-то, другие причины.

## Рост функционала

Методы, описанные выше, подходят лишь для самого примитивного варианта dataflow - pipeline dataflow. Практика показывает, что начав программировать в Dataflow стиле начинает постоянно хотеться большего: множественные порты, очереди с буфером, параллелизм...

Как видно из этой книги, многие реализации Dataflow могут быть достаточно компактными и при этом предоставлять до 90% необходимого функционала. Вместо того, чтобы постоянно расширять dataflow движок, почему бы просто не взять сразу готовый?

