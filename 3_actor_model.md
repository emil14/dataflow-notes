# Модель акторов

Модель акторов это динамичная форма dataflow где узлы и дуги могут добавляться и удаляться во время выполнения. Это форма конкурентного вычисления, близкая к ООП. Модель акторов, на самом деле, гораздо ближе к оригинальному определению ООП, чем большинство "ООП" языков.

Обмен сообщениями используется для отправки данных напрямую _актору_ асинхронно. Каждый актор имеет уникальный адрес. _Почтовый ящик_ (упорядоченная очередь) хранит полученные сообщения внутри актора.

Сообщения можно читать в любом порядке. Они сопоставляются с соответствующим методом актора и отправляются ему. Непонятное сообщение либо молча отбрасывается либо бросает ошибку.

Акторы могут посылать сообщения только знакомым акторам (чьи адресы им известны). Это либо адрес, содержащийся в самом сообщении, либо адрес порождённого (дочернего) актора.

Доставка сообщений не гарантирована. Для её гарантии надо использовать протокол подтверждения между акторами. Как и всегда в dataflow, получение сообщения вызывают активацию актора (узла). Выполнение происходит конкурентно.

Акторы _ссылочно прозрачны_ (функциональны/чисты/идемпотентны) в рамках вызова. Они могут иметь и изменять свой стейт но это не влияет на последующие вызовы. Строго говоря, они используют петли вместо состояний. Локальное состояние актора инкопсулировано и единственный способ с ним взаимодействовать это обмен сообщениями.

#### Отношение с ООП

Модель акторов очень похожа на ООП за исключением того, что методы не возвращают значений. Сообщение это форма неявного вызова и акторы никогда явно не вызывают методы друг друга. Это даёт возможность всем акторам работать друг с другом асинхронно. Как и _объекты_ акторы могут иметь локальное состояние и могут создаваться.

#### Отношение с Dataflow

Акторы отличаются от остальных форм dataflow, что мы обсудили до этого, где данные перемещаются по дугам. Об акторах можно думать как о dataflow, где дуги имеют вместимость 1 и создаются и уничтожаются всякий раз перед и после отправки сообщения. Это также асинхронная форма dataflow с функциональными (stateless) узлами, которые имитируют состояние с помощью циклов. Так как всё является актором, составные узлы легко создаются посредством описания акторов в терминах композиции ими других акторов.

#### Возможности Dataflow

- Асинхронная активация
- Динамическая структура программы
- Push подход
- Соединение и разделение дуг запрещено (дуги отсутствуют как концепт)
- Данные (сообщения) неизменяемы
- Функциональные узлы имитируют состояние посредством циклов, но и то лишь в рамках активации
- Множественные входные порты эмулируются тем, что один порт может принимать разные сообщения
- Множественные выходы эмулируются тем, что акторы могут отправлять сообщения напрямую множеству других акторов
- Из-за 1 входа (как в pipeline) нет смысла говорить о паттернах активации - активация происходит всегда, когда на входе есть токен
- Циклы разрешены
- Рекурсия не вызывает проблем т.к. акторы независимы друг от друга (нет дуг)
- Составные узлы разрешены
- Вместимость дуги (если рассуждать в терминах дуг) равна 1.
- Множественная обработка токенов: один на вход за активацию, сколько угодно на выходе.

#### Где применяется?

Модель акторов очень гибкая и динамичная и полезна там, где структура программы должна постоянно меняться во время выполнения:

- Системы, где невозможно определить, как узлы должны соединяться, до того как программа запущена
- Системы, где есть runtime фактор, влияющий на структуру программы. Например, веб-сервер, где нужно создавать новый актор для каждого запроса
- Системы, где _сервисы_ могут добавляться и удаляться прямо во время выполнения

#### Где это не применяется?

В системах, где структура программы по большей части статична, динамизм модели акторов скорее будет помехой. Например, заранее определённый пайплайн или эмуляция электросхемы. Для каких-то приложений соединения между узлами важны также как и сами узлы. Когда хочется убедиться, что можно просто переподключить узлы иначе, модель акторов это плохой выбор.

